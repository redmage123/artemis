#!/usr/bin/env python3
"""
WHY: Provide high-level API for building complete notebooks
RESPONSIBILITY: Orchestrate cell creation and notebook assembly
PATTERNS:
- Builder pattern with fluent API
- Composition for cell management
- Template method for notebook structure

This module provides the main API for programmatically creating Jupyter
notebooks with sections, code cells, and markdown documentation.
"""

from datetime import datetime
from typing import Dict, List, Optional, Any

from .models import NotebookCell, NotebookMetadata, CellType
from .builders import CellFactory


class NotebookBuilder:
    """
    WHY: Build complete Jupyter notebooks programmatically
    RESPONSIBILITY: Orchestrate cell creation and notebook assembly
    PATTERN: Builder pattern with fluent API
    PERFORMANCE: O(1) cell addition, lazy rendering
    """

    def __init__(self, title: Optional[str] = None):
        """
        WHY: Initialize notebook with optional title
        RESPONSIBILITY: Set up empty notebook with metadata

        Args:
            title: Optional notebook title (added as first markdown cell)

        What it initializes:
        - Empty cells list
        - Python 3 kernel metadata
        - Language info for syntax highlighting
        - Optional title cell with creation timestamp
        """
        self.cells: List[NotebookCell] = []
        self.metadata = NotebookMetadata().to_dict()

        # Guard clause: Add title cell if provided
        if not title:
            return

        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        title_text = f"# {title}\n\nGenerated by Artemis on {timestamp}"
        self.add_markdown(title_text)

    def add_markdown(self, content: str) -> 'NotebookBuilder':
        """
        WHY: Add markdown cell to notebook
        RESPONSIBILITY: Create and append markdown cell

        Args:
            content: Markdown text content

        Returns:
            Self for method chaining
        """
        cell = CellFactory.create_cell(CellType.MARKDOWN.value, content).build()
        self.cells.append(cell)
        return self

    def add_code(
        self,
        code: str,
        execution_count: Optional[int] = None
    ) -> 'NotebookBuilder':
        """
        WHY: Add code cell to notebook
        RESPONSIBILITY: Create and append code cell

        Args:
            code: Python code content
            execution_count: Optional execution sequence number

        Returns:
            Self for method chaining
        """
        builder = CellFactory.create_cell(CellType.CODE.value, code)

        # Guard clause: Add execution count if provided
        if execution_count is not None:
            builder.with_execution_count(execution_count)

        cell = builder.build()
        self.cells.append(cell)
        return self

    def add_section(
        self,
        title: str,
        description: Optional[str] = None
    ) -> 'NotebookBuilder':
        """
        WHY: Add section header with optional description
        RESPONSIBILITY: Create formatted section markdown

        Args:
            title: Section title
            description: Optional section description

        Returns:
            Self for method chaining
        """
        content = f"## {title}\n"

        # Guard clause: Add description if provided
        if description:
            content += f"\n{description}\n"

        return self.add_markdown(content)

    def with_metadata(self, metadata: Dict[str, Any]) -> 'NotebookBuilder':
        """
        WHY: Update notebook-level metadata
        RESPONSIBILITY: Merge custom metadata

        Args:
            metadata: Custom metadata dict

        Returns:
            Self for method chaining
        """
        self.metadata.update(metadata)
        return self

    def build(self) -> Dict[str, Any]:
        """
        WHY: Build complete notebook structure
        RESPONSIBILITY: Serialize cells and metadata to notebook dict

        Returns:
            Jupyter notebook as dict (ready for JSON serialization)
        """
        return {
            "cells": [cell.to_dict() for cell in self.cells],
            "metadata": self.metadata,
            "nbformat": 4,
            "nbformat_minor": 5
        }
