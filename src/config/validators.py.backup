#!/usr/bin/env python3
"""
Configuration Validators - Strategy Pattern Implementation

WHY: Implements individual validation strategies for different configuration aspects

RESPONSIBILITY: Provide validation strategies for LLM, database, messenger, paths, and resources

PATTERNS: Strategy pattern for validation checks, Guard clauses for early returns
"""

import os
from pathlib import Path
from typing import List, Dict, Any, Optional, Callable
from .models import ValidationResult
from .constants import (
    VALID_LLM_PROVIDERS,
    VALID_MESSENGER_TYPES,
    VALID_PERSISTENCE_TYPES,
    MIN_PARALLEL_DEVELOPERS,
    MAX_PARALLEL_DEVELOPERS,
    DEFAULT_LLM_PROVIDER,
    DEFAULT_MESSENGER_TYPE,
    DEFAULT_PERSISTENCE_TYPE,
    DEFAULT_MAX_PARALLEL_DEVELOPERS,
    DEFAULT_TEMP_DIR,
    DEFAULT_ADR_DIR,
    DEFAULT_DEVELOPER_DIR,
    DEFAULT_PERSISTENCE_DB,
    DEFAULT_RAG_DB_PATH,
    DEFAULT_MESSAGE_DIR,
    DEFAULT_RABBITMQ_URL,
    PROVIDER_CONFIGS
)
from .path_utils import resolve_relative_path, ensure_directory_writable, get_script_directory


class LLMProviderValidator:
    """
    Validates LLM provider configuration

    WHY: Single Responsibility - handles only LLM provider validation

    PATTERNS: Strategy pattern for provider-specific validation
    """

    def validate_provider(self) -> ValidationResult:
        """
        Check LLM provider configuration

        WHY: Validates that configured LLM provider is supported
        PERFORMANCE: O(1) set membership check

        Returns:
            ValidationResult for provider check
        """
        provider = os.getenv("ARTEMIS_LLM_PROVIDER", DEFAULT_LLM_PROVIDER)

        # Guard clause: Invalid provider
        if provider not in VALID_LLM_PROVIDERS:
            return ValidationResult(
                check_name="LLM Provider",
                passed=False,
                message=f"Invalid provider '{provider}'",
                fix_suggestion=f"Set ARTEMIS_LLM_PROVIDER to one of: {', '.join(VALID_LLM_PROVIDERS)}"
            )

        # Success case
        return ValidationResult(
            check_name="LLM Provider",
            passed=True,
            message=f"Provider set to '{provider}'"
        )

    def validate_api_keys(self) -> ValidationResult:
        """
        Check LLM API keys are present

        WHY: Validates API keys before pipeline runs to fail fast
        PATTERNS: Strategy pattern via dictionary mapping, guard clauses for early returns
        PERFORMANCE: O(1) dictionary lookup

        Returns:
            ValidationResult for API key check
        """
        provider = os.getenv("ARTEMIS_LLM_PROVIDER", DEFAULT_LLM_PROVIDER)

        # Guard clause: Unknown provider
        config = PROVIDER_CONFIGS.get(provider)
        if not config:
            return ValidationResult(
                check_name="LLM Provider",
                passed=False,
                message=f"Unknown provider: {provider}",
                fix_suggestion="Set ARTEMIS_LLM_PROVIDER to 'openai', 'anthropic', or 'mock'"
            )

        # Guard clause: Mock provider (no API key needed)
        if config.get("is_mock"):
            return ValidationResult(
                check_name=config["name"],
                passed=True,
                message="Using mock LLM (no API key needed)",
                severity="warning"
            )

        # Check API key for real providers
        api_key = os.getenv(config["env_var"])

        # Guard clause: API key not set
        if not api_key:
            return ValidationResult(
                check_name=config["name"],
                passed=False,
                message=f"{config['env_var']} not set",
                fix_suggestion=config["fix_suggestion"]
            )

        # Guard clause: Validate format if validator provided
        if config.get("validator") and not config["validator"](api_key):
            return ValidationResult(
                check_name=config["name"],
                passed=False,
                message=config["error_msg"],
                fix_suggestion=config.get("validation_msg", config["fix_suggestion"])
            )

        # Success case: API key present and valid
        return ValidationResult(
            check_name=config["name"],
            passed=True,
            message="API key present" + (" and valid format" if config.get("validator") else "")
        )


class PathValidator:
    """
    Validates file paths exist and are writable

    WHY: Single Responsibility - handles only path validation

    PATTERNS: Guard clauses for early returns
    """

    def validate_paths(self) -> List[ValidationResult]:
        """
        Check important file paths exist and are writable

        WHY: Validates file system access before pipeline runs
        PERFORMANCE: O(n) where n is number of paths to check

        Returns:
            List of ValidationResult for each path check
        """
        script_dir = get_script_directory()

        temp_dir = os.getenv("ARTEMIS_TEMP_DIR", DEFAULT_TEMP_DIR)
        adr_dir = os.getenv("ARTEMIS_ADR_DIR", DEFAULT_ADR_DIR)
        developer_dir = os.getenv("ARTEMIS_DEVELOPER_DIR", DEFAULT_DEVELOPER_DIR)

        # Convert relative paths to absolute
        temp_dir = resolve_relative_path(temp_dir, script_dir)
        adr_dir = resolve_relative_path(adr_dir, script_dir)
        developer_dir = resolve_relative_path(developer_dir, script_dir)

        paths_to_check = [
            (temp_dir, "Temp directory"),
            (adr_dir, "ADR directory"),
            (f"{developer_dir}/developer-a", "Developer A output"),
            (f"{developer_dir}/developer-b", "Developer B output"),
        ]

        results = []
        for path_str, description in paths_to_check:
            path = Path(path_str)
            success, error_msg = ensure_directory_writable(path)

            if success:
                results.append(ValidationResult(
                    check_name=f"Path: {description}",
                    passed=True,
                    message=f"{path} exists and writable",
                    severity="info"
                ))
            else:
                results.append(ValidationResult(
                    check_name=f"Path: {description}",
                    passed=False,
                    message=f"{path} not writable: {error_msg}",
                    fix_suggestion=f"Ensure {path} exists and has write permissions"
                ))

        return results


class DatabaseValidator:
    """
    Validates database/persistence access

    WHY: Single Responsibility - handles only database validation

    PATTERNS: Strategy pattern via dispatch table
    """

    def validate_database(self) -> ValidationResult:
        """
        Check database/persistence access

        WHY: Validates database connectivity before pipeline runs
        PATTERNS: Strategy pattern via dictionary mapping

        Returns:
            ValidationResult for database check
        """
        persistence_type = os.getenv("ARTEMIS_PERSISTENCE_TYPE", DEFAULT_PERSISTENCE_TYPE)

        # Strategy pattern: Dictionary mapping instead of if/elif
        # WHY: Makes it easy to add new persistence types without modifying code
        database_checks: Dict[str, Callable[[], ValidationResult]] = {
            "sqlite": self._check_sqlite,
            "postgres": self._check_postgres
        }

        check_func = database_checks.get(persistence_type)
        if not check_func:
            return ValidationResult(
                check_name="Database",
                passed=False,
                message=f"Unknown persistence type: {persistence_type}",
                fix_suggestion="Set ARTEMIS_PERSISTENCE_TYPE to 'sqlite' or 'postgres'"
            )

        return check_func()

    def _check_sqlite(self) -> ValidationResult:
        """
        Check SQLite database access

        WHY: Extracted to avoid nested if statements and improve readability
        PERFORMANCE: O(1) database connection check

        Returns:
            ValidationResult for SQLite check
        """
        db_path = os.getenv("ARTEMIS_PERSISTENCE_DB", DEFAULT_PERSISTENCE_DB)

        # Convert relative path to absolute early
        script_dir = get_script_directory()
        db_path = resolve_relative_path(db_path, script_dir)

        db_file = Path(db_path)

        try:
            # Try to create/access database
            import sqlite3
            conn = sqlite3.connect(db_file)
            cursor = conn.cursor()
            cursor.execute("SELECT 1")
            conn.close()

            return ValidationResult(
                check_name="SQLite Database",
                passed=True,
                message=f"Database accessible at {db_path}"
            )
        except Exception as e:
            return ValidationResult(
                check_name="SQLite Database",
                passed=False,
                message=f"Cannot access database: {e}",
                fix_suggestion=f"Check permissions on {db_path}"
            )

    def _check_postgres(self) -> ValidationResult:
        """
        Check PostgreSQL database access

        WHY: Extracted to separate method for clarity
        PERFORMANCE: O(1) - currently just logs warning

        Returns:
            ValidationResult for PostgreSQL check
        """
        return ValidationResult(
            check_name="PostgreSQL Database",
            passed=False,
            message="PostgreSQL persistence not yet implemented",
            severity="warning",
            fix_suggestion="Use ARTEMIS_PERSISTENCE_TYPE=sqlite for now"
        )


class MessengerValidator:
    """
    Validates messenger backend availability

    WHY: Single Responsibility - handles only messenger validation

    PATTERNS: Strategy pattern for different messenger types
    """

    def validate_messenger(self) -> ValidationResult:
        """
        Check messenger backend availability

        WHY: Validates messaging system before pipeline runs
        PATTERNS: Strategy pattern via dictionary mapping
        PERFORMANCE: O(1) for file check, O(n) for network check (RabbitMQ)

        Returns:
            ValidationResult for messenger check
        """
        messenger_type = os.getenv("ARTEMIS_MESSENGER_TYPE", DEFAULT_MESSENGER_TYPE)

        # Strategy pattern: Dictionary mapping instead of if/elif chain
        # WHY: Makes it easy to add new messenger types without modifying code structure
        messenger_checks: Dict[str, Callable[[], ValidationResult]] = {
            "file": self._check_file_messenger,
            "rabbitmq": self._check_rabbitmq_messenger,
            "mock": self._check_mock_messenger
        }

        check_func = messenger_checks.get(messenger_type)
        if not check_func:
            return ValidationResult(
                check_name="Messenger",
                passed=False,
                message=f"Unknown messenger type: {messenger_type}",
                fix_suggestion="Set ARTEMIS_MESSENGER_TYPE to 'file', 'rabbitmq', or 'mock'"
            )

        return check_func()

    def _check_file_messenger(self) -> ValidationResult:
        """
        Check file-based messenger

        WHY: Extracted to avoid nested if statements
        PERFORMANCE: O(1) directory creation check

        Returns:
            ValidationResult for file messenger check
        """
        message_dir = os.getenv("ARTEMIS_MESSAGE_DIR", DEFAULT_MESSAGE_DIR)
        try:
            Path(message_dir).mkdir(parents=True, exist_ok=True)
            return ValidationResult(
                check_name="File Messenger",
                passed=True,
                message=f"Message directory accessible: {message_dir}"
            )
        except Exception as e:
            return ValidationResult(
                check_name="File Messenger",
                passed=False,
                message=f"Cannot create message directory: {e}",
                fix_suggestion=f"Ensure {message_dir} is writable"
            )

    def _check_rabbitmq_messenger(self) -> ValidationResult:
        """
        Check RabbitMQ messenger

        WHY: Extracted to avoid nested if statements
        PERFORMANCE: O(n) network connection with 1 retry (short timeout)

        Returns:
            ValidationResult for RabbitMQ messenger check
        """
        try:
            import pika
            rabbitmq_url = os.getenv("ARTEMIS_RABBITMQ_URL", DEFAULT_RABBITMQ_URL)
            # Try to connect (with short timeout)
            params = pika.URLParameters(rabbitmq_url)
            params.connection_attempts = 1
            params.retry_delay = 1
            conn = pika.BlockingConnection(params)
            conn.close()

            return ValidationResult(
                check_name="RabbitMQ Messenger",
                passed=True,
                message=f"Connected to RabbitMQ at {rabbitmq_url}"
            )
        except ImportError:
            return ValidationResult(
                check_name="RabbitMQ Messenger",
                passed=False,
                message="pika library not installed",
                fix_suggestion="pip install pika"
            )
        except Exception as e:
            return ValidationResult(
                check_name="RabbitMQ Messenger",
                passed=False,
                message=f"Cannot connect to RabbitMQ: {e}",
                fix_suggestion="Ensure RabbitMQ is running: docker run -d -p 5672:5672 rabbitmq"
            )

    def _check_mock_messenger(self) -> ValidationResult:
        """
        Check mock messenger

        WHY: Extracted for consistency with other messenger checks
        PERFORMANCE: O(1) - no actual check needed

        Returns:
            ValidationResult for mock messenger check
        """
        return ValidationResult(
            check_name="Mock Messenger",
            passed=True,
            message="Using mock messenger (testing mode)",
            severity="warning"
        )


class RAGDatabaseValidator:
    """
    Validates RAG database (ChromaDB) access

    WHY: Single Responsibility - handles only RAG database validation

    PATTERNS: Guard clauses for early returns
    """

    def validate_rag_database(self) -> ValidationResult:
        """
        Check RAG database (ChromaDB) access

        WHY: Validates ChromaDB availability for RAG features
        PERFORMANCE: O(1) import and directory check

        Returns:
            ValidationResult for RAG database check
        """
        # Get RAG DB path from env or use default relative to script directory
        rag_db_path = os.getenv("ARTEMIS_RAG_DB_PATH", DEFAULT_RAG_DB_PATH)
        script_dir = get_script_directory()
        rag_db_path = resolve_relative_path(rag_db_path, script_dir)

        try:
            # Try to import chromadb
            import chromadb

            # Try to create/access database
            Path(rag_db_path).mkdir(parents=True, exist_ok=True)

            return ValidationResult(
                check_name="RAG Database (ChromaDB)",
                passed=True,
                message=f"ChromaDB accessible at {rag_db_path}"
            )
        except ImportError:
            return ValidationResult(
                check_name="RAG Database (ChromaDB)",
                passed=False,
                message="chromadb library not installed",
                severity="warning",
                fix_suggestion="pip install chromadb (optional but recommended)"
            )
        except Exception as e:
            return ValidationResult(
                check_name="RAG Database (ChromaDB)",
                passed=False,
                message=f"Cannot access RAG database: {e}",
                severity="warning",
                fix_suggestion=f"Check permissions on {rag_db_path}"
            )


class ResourceLimitValidator:
    """
    Validates resource limits are reasonable

    WHY: Single Responsibility - handles only resource limit validation

    PATTERNS: Guard clauses for early returns
    """

    def validate_resource_limits(self) -> List[ValidationResult]:
        """
        Check resource limits are reasonable

        WHY: Validates configured resource limits before pipeline runs
        PERFORMANCE: O(1) environment variable checks

        Returns:
            List of ValidationResult for resource limit checks
        """
        results = []

        # Check max parallel developers
        max_devs = int(os.getenv("ARTEMIS_MAX_PARALLEL_DEVELOPERS", DEFAULT_MAX_PARALLEL_DEVELOPERS))
        if MIN_PARALLEL_DEVELOPERS <= max_devs <= MAX_PARALLEL_DEVELOPERS:
            results.append(ValidationResult(
                check_name="Parallel Developers",
                passed=True,
                message=f"Max parallel developers: {max_devs}",
                severity="info"
            ))
        else:
            results.append(ValidationResult(
                check_name="Parallel Developers",
                passed=False,
                message=f"Invalid max parallel developers: {max_devs}",
                severity="warning",
                fix_suggestion=f"Set ARTEMIS_MAX_PARALLEL_DEVELOPERS between {MIN_PARALLEL_DEVELOPERS} and {MAX_PARALLEL_DEVELOPERS}"
            ))

        # Check budgets if set
        daily_budget = os.getenv("ARTEMIS_DAILY_BUDGET")

        # Guard clause: No budget set
        if not daily_budget:
            return results

        # Validate budget value
        try:
            budget = float(daily_budget)
        except ValueError:
            results.append(ValidationResult(
                check_name="Daily Budget",
                passed=False,
                message=f"Invalid daily budget: {daily_budget}",
                severity="warning",
                fix_suggestion="Set ARTEMIS_DAILY_BUDGET to a number (e.g., 10.00)"
            ))
            return results

        # Guard clause: Budget must be positive
        if budget <= 0:
            results.append(ValidationResult(
                check_name="Daily Budget",
                passed=False,
                message="Daily budget must be positive",
                severity="warning"
            ))
            return results

        # Success case: Valid budget
        results.append(ValidationResult(
            check_name="Daily Budget",
            passed=True,
            message=f"Daily budget: ${budget:.2f}",
            severity="info"
        ))

        return results


class OptionalServiceValidator:
    """
    Validates optional services

    WHY: Single Responsibility - handles only optional service validation

    PATTERNS: Guard clauses for early returns
    """

    def validate_optional_services(self) -> List[ValidationResult]:
        """
        Check optional services

        WHY: Validates optional services if configured
        PERFORMANCE: O(1) environment variable check, O(n) for Redis if present

        Returns:
            List of ValidationResult for optional service checks
        """
        results = []
        redis_url = os.getenv("REDIS_URL")

        # Guard clause: No Redis configured
        if not redis_url:
            return results

        results.append(self._check_redis_service(redis_url))
        return results

    def _check_redis_service(self, redis_url: str) -> ValidationResult:
        """
        Check Redis service availability

        WHY: Extracted to avoid nested if statements and improve testability
        PERFORMANCE: Uses socket_connect_timeout to avoid long waits (O(1) with timeout)

        Args:
            redis_url: Redis connection URL

        Returns:
            ValidationResult for Redis check
        """
        try:
            import redis
            client = redis.from_url(redis_url, socket_connect_timeout=2)
            client.ping()
            return ValidationResult(
                check_name="Redis (Optional)",
                passed=True,
                message=f"Connected to Redis at {redis_url}",
                severity="info"
            )
        except ImportError:
            return ValidationResult(
                check_name="Redis (Optional)",
                passed=False,
                message="redis library not installed",
                severity="warning",
                fix_suggestion="pip install redis (optional)"
            )
        except Exception as e:
            return ValidationResult(
                check_name="Redis (Optional)",
                passed=False,
                message=f"Cannot connect to Redis: {e}",
                severity="warning",
                fix_suggestion="Ensure Redis is running or unset REDIS_URL"
            )
