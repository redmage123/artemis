from artemis_logger import get_logger
logger = get_logger('project_analysis_agent')
'\nWHY: Backward compatibility wrapper for project_analysis_agent module\nRESPONSIBILITY: Re-export all components from refactored package\nPATTERNS: Facade pattern, deprecation path\n\nBACKWARD COMPATIBILITY WRAPPER\n===============================\nThis module maintains backward compatibility with existing code that imports\nfrom project_analysis_agent.py. All functionality has been refactored into\nthe project_analysis/ package following SOLID principles.\n\nOriginal file: 1,080 lines (monolithic)\nRefactored: 6 modules with clear separation of concerns\n\nMigration Guide:\n---------------\nOld import:\n    from project_analysis_agent import ProjectAnalysisEngine, analyze_project\n\nNew import (recommended):\n    from project_analysis import ProjectAnalysisEngine, analyze_project\n\nOr use specific imports:\n    from project_analysis.engine import ProjectAnalysisEngine\n    from project_analysis.models import Severity, Issue, AnalysisResult\n    from project_analysis.analyzers import ScopeAnalyzer, SecurityAnalyzer\n\nModule Structure:\n----------------\nproject_analysis/\n├── __init__.py                    # Public API\n├── models.py                      # Data classes and enums (95 lines)\n├── interfaces.py                  # Abstract base class (51 lines)\n├── engine.py                      # Analysis orchestration (221 lines)\n├── approval_handler.py            # User approval logic (121 lines)\n└── analyzers/\n    ├── __init__.py               # Analyzer exports\n    ├── rule_based.py             # Rule-based analyzers (314 lines)\n    └── llm_powered.py            # LLM-powered analyzer (388 lines)\n\nBenefits:\n---------\n✓ Single Responsibility: Each module has one clear purpose\n✓ Open/Closed: Add new analyzers without modifying existing code\n✓ Liskov Substitution: All analyzers implement DimensionAnalyzer interface\n✓ Interface Segregation: Minimal, focused interfaces\n✓ Dependency Inversion: Depends on abstractions, not concrete implementations\n✓ Guard Clauses: Max 1 level nesting throughout\n✓ Type Hints: Full type annotations (List, Dict, Any, Optional, Callable)\n✓ Testability: Each component can be tested independently\n'
from project_analysis import Severity, Issue, AnalysisResult, ApprovalOptions, DimensionAnalyzer, ProjectAnalysisEngine, analyze_project, ScopeAnalyzer, SecurityAnalyzer, PerformanceAnalyzer, TestingAnalyzer, ErrorHandlingAnalyzer, LLMPoweredAnalyzer, UserApprovalHandler
__all__ = ['Severity', 'Issue', 'AnalysisResult', 'ApprovalOptions', 'DimensionAnalyzer', 'ProjectAnalysisEngine', 'analyze_project', 'ScopeAnalyzer', 'SecurityAnalyzer', 'PerformanceAnalyzer', 'TestingAnalyzer', 'ErrorHandlingAnalyzer', 'LLMPoweredAnalyzer', 'UserApprovalHandler']
if __name__ == '__main__':
    
    logger.log('Project Analysis Agent - Example', 'INFO')
    
    logger.log('=' * 60, 'INFO')
    card = {'card_id': 'test-001', 'title': 'Add user authentication', 'description': 'Add login functionality', 'priority': 'high', 'points': 8}
    analysis = analyze_project(card)
    handler = UserApprovalHandler()
    presentation = handler.present_findings(analysis)
    
    logger.log(presentation, 'INFO')