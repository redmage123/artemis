"""
Module: two_pass/pipeline.py

WHY: Main two-pass pipeline orchestrator.
RESPONSIBILITY: TwoPassPipeline orchestrates first pass, second pass, comparison, rollback.
PATTERNS: Template Method, Strategy, Memento, Observer, Guard Clauses.

This module handles:
- Execute first pass (fast analysis)
- Capture memento
- Execute second pass (refined with learnings)
- Compare results
- Rollback on failure

EXTRACTED FROM: two_pass_pipeline.py (lines 1405-2039, 635 lines)
"""

from typing import Dict, Any, Optional, List
from datetime import datetime
import time

from two_pass.models import PassResult, PassDelta, PassMemento
from two_pass.strategies import PassStrategy, FirstPassStrategy, SecondPassStrategy
from two_pass.comparator import PassComparator
from two_pass.rollback import RollbackManager
from two_pass.events import TwoPassEventType
from two_pass.exceptions import (
    TwoPassPipelineException,
    FirstPassException,
    SecondPassException
)
from artemis_exceptions import wrap_exception
from artemis_services import PipelineLogger
from pipeline_observer import PipelineObservable, PipelineEvent, EventType
from advanced_features_ai_mixin import AdvancedFeaturesAIMixin

class TwoPassPipeline(AdvancedFeaturesAIMixin):
    """
    Orchestrates two-pass pipeline execution with learning and rollback.

    Why it exists: Main entry point for two-pass pipeline. Coordinates first pass,
    second pass, comparison, and rollback. Implements complete two-pass workflow.

    Design pattern: Facade + Template Method + Observer + Mixin (for DRY AI calls)
    Why this design:
    - Facade: Simplifies complex multi-component interaction (strategies, comparator, rollback)
    - Template Method: Defines overall workflow with customization points
    - Observer: Broadcasts events at every workflow stage

    Responsibilities:
    - Execute first pass and capture state
    - Transfer learnings to second pass
    - Execute second pass with refinements
    - Compare pass results
    - Decide on rollback if needed
    - Emit events for observability
    - Manage retry on transient failures

    Workflow:
    1. Execute first pass (fast analysis)
    2. Create memento of first pass state
    3. Apply memento to second pass context
    4. Execute second pass (refined implementation)
    5. Compare results and detect delta
    6. Rollback if quality degraded
    7. Return final result

    Thread-safety: Not thread-safe (assumes single-threaded execution)
    """

    def __init__(
        self,
        first_pass_strategy: PassStrategy,
        second_pass_strategy: PassStrategy,
        context: Optional[Dict[str, Any]] = None,
        observable: Optional[PipelineObservable] = None,
        auto_rollback: bool = True,
        rollback_threshold: float = -0.1,
        verbose: bool = True
    ):
        """
        Initialize two-pass pipeline orchestrator.

        Why needed: Sets up all components (strategies, comparator, rollback manager)
        and configures behavior (auto-rollback, threshold).

        NEW: Hybrid AI Approach - Accepts context from router with pre-computed analysis.

        Args:
            first_pass_strategy: Strategy for first pass execution
            second_pass_strategy: Strategy for second pass execution
            context: Router context with pre-computed analysis (intensity, guidance, etc.)
            observable: Event broadcaster for observer pattern
            auto_rollback: Automatically rollback if second pass degrades quality
            rollback_threshold: Quality degradation threshold for auto-rollback (-0.1 = 10% worse)
            verbose: Enable detailed logging
        """
        self.first_pass_strategy = first_pass_strategy
        self.second_pass_strategy = second_pass_strategy
        self.observable = observable
        self.auto_rollback = auto_rollback
        self.rollback_threshold = rollback_threshold
        self.verbose = verbose
        self.logger = PipelineLogger(verbose=verbose)

        # NEW: Extract router context for hybrid AI approach
        if context:
            self.ai_service = context.get('ai_service')  # For adaptive calls
            self.router_intensity = context.get('intensity', 0.5)
            self.router_guidance = context.get('prompt', '')
            self.first_pass_timeout = context.get('first_pass_timeout', 30)
            self.second_pass_timeout = context.get('second_pass_timeout', 120)
            self.quality_threshold = context.get('quality_threshold', 0.7)
            self.first_pass_guidance = context.get('first_pass_guidance', [])
            self.second_pass_guidance = context.get('second_pass_guidance', [])
            self.context = context
        else:
            # Fallback for legacy support
            self.ai_service = None
            self.router_intensity = 0.5
            self.router_guidance = ''
            self.first_pass_timeout = 30
            self.second_pass_timeout = 120
            self.quality_threshold = 0.7
            self.first_pass_guidance = []
            self.second_pass_guidance = []
            self.context = {}

        # Initialize components
        self.comparator = PassComparator(observable=observable, verbose=verbose)
        self.rollback_manager = RollbackManager(observable=observable, verbose=verbose)
        self.retry_strategy = RetryStrategy(
            RetryConfig(max_retries=3, verbose=verbose)
        )

        # State tracking
        self.first_pass_memento: Optional[PassMemento] = None
        self.execution_history: List[Dict[str, Any]] = []

    @wrap_exception(TwoPassPipelineException, "Two-pass pipeline execution failed")
    def execute(self, context: Dict[str, Any]) -> PassResult:
        """
        Execute complete two-pass pipeline workflow.

        What it does:
        1. Execute first pass with retry
        2. Create and store memento
        3. Apply memento to second pass context
        4. Execute second pass with retry
        5. Compare results
        6. Auto-rollback if configured and quality degraded
        7. Return final result (second pass or rolled back first pass)

        Args:
            context: Execution context with inputs, config, etc.

        Returns:
            Final PassResult (second pass if successful, first pass if rolled back)

        Raises:
            TwoPassPipelineException: On critical failure

        Design notes:
        - Uses retry strategy for resilience
        - Emits events at every major step
        - Auto-rollback is configurable
        - Preserves execution history for audit
        """
        execution_start = datetime.now()

        # Execute first pass with retry
        first_pass_result = self._execute_first_pass_with_retry(context)

        # Create memento from first pass
        self.first_pass_memento = self._create_memento(first_pass_result, context)

        # Apply memento to second pass context
        second_pass_context = self._prepare_second_pass_context(context)

        # Execute second pass with retry
        second_pass_result = self._execute_second_pass_with_retry(second_pass_context)

        # Compare results
        delta = self.comparator.compare(first_pass_result, second_pass_result)

        # Decide final result (may rollback)
        final_result = self._determine_final_result(
            first_pass_result,
            second_pass_result,
            delta
        )

        # Record execution in history
        self._record_execution(
            first_pass_result,
            second_pass_result,
            delta,
            final_result,
            execution_start
        )

        return final_result

    def _execute_first_pass_with_retry(self, context: Dict[str, Any]) -> PassResult:
        """
        Execute first pass with retry on transient failures.

        Why extracted: Encapsulates retry logic. Avoids nesting retry loop in execute().

        Args:
            context: Execution context

        Returns:
            First pass result

        Raises:
            FirstPassException: On persistent failure
        """
        def _execute() -> PassResult:
            return self.first_pass_strategy.execute(context)

        return self.retry_strategy.retry(_execute)

    def _create_memento(self, result: PassResult, context: Dict[str, Any]) -> PassMemento:
        """
        Create memento from first pass result.

        Why extracted: Separates memento creation from execution. Emits event for tracking.

        Args:
            result: First pass result
            context: Execution context

        Returns:
            PassMemento with state snapshot
        """
        memento = self.first_pass_strategy.create_memento(result, context)

        # Emit memento created event
        if self.observable:
            event = PipelineEvent(
                event_type=EventType.STAGE_PROGRESS,
                stage_name="TwoPassPipeline",
                data={
                    "two_pass_event": TwoPassEventType.MEMENTO_CREATED.value,
                    "pass_name": result.pass_name,
                    "quality_score": result.quality_score,
                    "learnings_count": len(result.learnings)
                }
            )
            self.observable.notify(event)

        return memento

    def _prepare_second_pass_context(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Prepare second pass context with first pass learnings.

        Why extracted: Encapsulates context preparation logic. Creates new context
        dict to avoid mutating original.

        Args:
            context: Original context

        Returns:
            New context with memento applied
        """
        # Guard clause - need memento to prepare context
        if not self.first_pass_memento:
            raise TwoPassPipelineException("No first pass memento available")

        # Create new context (don't mutate original)
        second_pass_context = copy.deepcopy(context)

        # Apply memento to context
        self.second_pass_strategy.apply_memento(self.first_pass_memento, second_pass_context)

        # Emit memento applied event
        if self.observable:
            event = PipelineEvent(
                event_type=EventType.STAGE_PROGRESS,
                stage_name="TwoPassPipeline",
                data={
                    "two_pass_event": TwoPassEventType.MEMENTO_APPLIED.value,
                    "learnings_applied": len(second_pass_context.get("learnings", [])),
                    "insights_applied": len(second_pass_context.get("insights", {}))
                }
            )
            self.observable.notify(event)

        return second_pass_context

    def _execute_second_pass_with_retry(self, context: Dict[str, Any]) -> PassResult:
        """
        Execute second pass with retry on transient failures.

        Why extracted: Encapsulates retry logic. Avoids nesting retry loop in execute().

        Args:
            context: Second pass context with learnings

        Returns:
            Second pass result

        Raises:
            SecondPassException: On persistent failure
        """
        def _execute() -> PassResult:
            return self.second_pass_strategy.execute(context)

        return self.retry_strategy.retry(_execute)

    def _determine_final_result(
        self,
        first_pass: PassResult,
        second_pass: PassResult,
        delta: PassDelta
    ) -> PassResult:
        """
        Determine final result (may rollback to first pass).

        Why extracted: Encapsulates rollback decision logic. Uses dispatch table
        instead of if/elif for extensibility.

        Args:
            first_pass: First pass result
            second_pass: Second pass result
            delta: Comparison delta

        Returns:
            Final result (second pass or first pass if rolled back)
        """
        # Guard clause - if auto-rollback disabled, always use second pass
        if not self.auto_rollback:
            return second_pass

        # Determine if rollback needed
        should_rollback = self.rollback_manager.should_rollback(delta, self.rollback_threshold)

        # Guard clause - if rollback not needed, use second pass
        if not should_rollback:
            return second_pass

        # Rollback to first pass
        if self.verbose:
            self.logger.log(
                f"Rolling back to first pass (quality degraded by {abs(delta.quality_delta):.2%})",
                "WARNING"
            )

        # Perform rollback
        self.rollback_manager.rollback_to_memento(
            self.first_pass_memento,
            reason=f"Quality degraded by {abs(delta.quality_delta):.2%}"
        )

        return first_pass

    def _record_execution(
        self,
        first_pass: PassResult,
        second_pass: PassResult,
        delta: PassDelta,
        final_result: PassResult,
        start_time: datetime
    ) -> None:
        """
        Record execution in history for audit trail.

        Why extracted: Separates history tracking from execution logic.

        Args:
            first_pass: First pass result
            second_pass: Second pass result
            delta: Comparison delta
            final_result: Final result (may be first or second pass)
            start_time: Execution start timestamp
        """
        execution_time = (datetime.now() - start_time).total_seconds()

        self.execution_history.append({
            "timestamp": start_time.isoformat(),
            "execution_time": execution_time,
            "first_pass_quality": first_pass.quality_score,
            "second_pass_quality": second_pass.quality_score,
            "quality_delta": delta.quality_delta,
            "final_pass": final_result.pass_name,
            "rolled_back": final_result.pass_name == first_pass.pass_name
        })

    def get_execution_history(self) -> List[Dict[str, Any]]:
        """Get execution history for audit trail"""
        return self.execution_history.copy()

    def get_rollback_history(self) -> List[Dict[str, Any]]:
        """Get rollback history from rollback manager"""
        return self.rollback_manager.get_rollback_history()

    # ========================================================================
    # HYBRID AI METHODS (Using Mixin)
    # ========================================================================

    @wrap_exception(TwoPassPipelineException, "AI-enhanced quality assessment failed")
    def assess_pass_quality_with_ai(
        self,
        code: str,
        requirements: str = "",
        previous_version: Optional[str] = None,
        use_initial_analysis: bool = True
    ) -> Dict[str, Any]:
        """
        Assess pass quality using hybrid AI approach.

        NEW: Demonstrates hybrid pattern for TwoPassPipeline:
        1. Start with router's pre-computed quality threshold (free!)
        2. Make adaptive AI call if detailed assessment needed (via mixin)
        3. Return comprehensive quality evaluation

        WHY: Shows integration of router context + adaptive AI calls for quality assessment.

        Args:
            code: Code to evaluate
            requirements: Requirements for context
            previous_version: Previous pass version for comparison
            use_initial_analysis: If True, uses router's pre-computed threshold first

        Returns:
            Dict with quality assessment including:
                - overall_score: float - Overall quality score (0.0-1.0)
                - criteria_scores: Dict[str, float] - Individual quality criteria
                - improvement: float - Improvement over previous version (if provided)
                - meets_threshold: bool - Whether quality meets router's threshold
                - source: str - Where assessment came from
                - suggestions: List[str] - Improvement suggestions

        Usage:
            # Uses hybrid approach
            assessment = pipeline.assess_pass_quality_with_ai(
                code=implementation_code,
                requirements=task_requirements,
                previous_version=first_pass_code
            )
        """
        # HYBRID STEP 1: Use router's pre-computed threshold (FREE!)
        if use_initial_analysis and self.quality_threshold is not None:
            # Router already provided quality threshold based on task analysis
            # For simple tasks, basic heuristics sufficient
            if self.router_intensity < 0.4:
                # Simple task - basic quality check
                basic_score = min(1.0, 0.5 + (self.router_intensity * 0.5))
                return {
                    'overall_score': basic_score,
                    'criteria_scores': {
                        'correctness': basic_score,
                        'completeness': basic_score,
                        'maintainability': basic_score
                    },
                    'improvement': 0.0,
                    'meets_threshold': basic_score >= self.quality_threshold,
                    'source': 'router_precomputed',
                    'suggestions': [],
                    'cost': 0.0  # Free!
                }

        # HYBRID STEP 2: Complex task or threshold not met - make adaptive AI call
        if not self.ai_service:
            # Fallback: No AI service available, use conservative estimate
            fallback_score = self.quality_threshold if self.quality_threshold else 0.7
            return {
                'overall_score': fallback_score,
                'criteria_scores': {
                    'correctness': fallback_score,
                    'completeness': fallback_score,
                    'maintainability': fallback_score
                },
                'improvement': 0.0,
                'meets_threshold': True,
                'source': 'fallback_no_ai_service',
                'suggestions': [],
                'warning': 'No AI service available, conservative estimate'
            }

        # Make AI call via mixin method for quality evaluation (DRY!)
        ai_quality = self.query_for_quality(
            code=code,
            requirements=requirements,
            previous_version=previous_version
        )

        # Calculate improvement if previous version provided
        improvement = 0.0
        if previous_version and ai_quality.comparison:
            improvement = ai_quality.comparison.get('improvement', 0.0)

        return {
            'overall_score': ai_quality.overall_score,
            'criteria_scores': ai_quality.criteria_scores,
            'improvement': improvement,
            'meets_threshold': ai_quality.overall_score >= self.quality_threshold,
            'source': 'ai_assessed',
            'suggestions': ai_quality.suggestions,
            'ai_reasoning': ai_quality.reasoning,
            'model_used': ai_quality.model_used,
            'detailed_comparison': ai_quality.comparison,
            'initial_threshold': self.quality_threshold,
            'quality_delta': ai_quality.overall_score - self.quality_threshold
        }

    @wrap_exception(TwoPassPipelineException, "AI-enhanced strategy optimization failed")
    def optimize_pass_strategy_with_ai(
        self,
        task_requirements: str,
        context_info: Dict[str, Any],
        use_initial_analysis: bool = True
    ) -> Dict[str, Any]:
        """
        Optimize pass execution strategy using hybrid AI approach.

        NEW: Uses router's intensity and guidance to optimize first/second pass strategy.

        Args:
            task_requirements: Task requirements description
            context_info: Additional context information
            use_initial_analysis: If True, uses router's pre-computed strategy first

        Returns:
            Dict with optimized strategy including:
                - first_pass_focus: List[str] - What first pass should focus on
                - second_pass_focus: List[str] - What second pass should focus on
                - recommended_timeouts: Dict[str, int] - Timeout recommendations
                - parallelization: bool - Whether passes can be partially parallelized
                - rollback_likelihood: float - Probability of needing rollback
                - source: str - Where optimization came from

        Usage:
            strategy = pipeline.optimize_pass_strategy_with_ai(
                task_requirements=requirements_text,
                context_info=execution_context
            )
        """
        # HYBRID STEP 1: Use router's pre-computed strategy (FREE!)
        if use_initial_analysis and self.router_intensity is not None:
            # Router already provided intensity and guidance
            # For low intensity, simple strategy sufficient
            if self.router_intensity < 0.5:
                return {
                    'first_pass_focus': self.first_pass_guidance if self.first_pass_guidance else [
                        'Validate requirements',
                        'Check for obvious issues',
                        'Quick feasibility check'
                    ],
                    'second_pass_focus': self.second_pass_guidance if self.second_pass_guidance else [
                        'Implement core functionality',
                        'Apply first pass learnings'
                    ],
                    'recommended_timeouts': {
                        'first_pass': self.first_pass_timeout,
                        'second_pass': self.second_pass_timeout
                    },
                    'parallelization': False,  # Conservative for simple tasks
                    'rollback_likelihood': 0.1,  # Low for simple tasks
                    'source': 'router_precomputed',
                    'intensity': self.router_intensity,
                    'cost': 0.0  # Free!
                }

        # HYBRID STEP 2: Higher intensity - make adaptive AI call
        if not self.ai_service:
            # Fallback: Use router's guidance with defaults
            return {
                'first_pass_focus': self.first_pass_guidance if self.first_pass_guidance else [
                    'Analyze requirements',
                    'Identify risks',
                    'Create execution plan'
                ],
                'second_pass_focus': self.second_pass_guidance if self.second_pass_guidance else [
                    'Full implementation',
                    'Apply optimizations',
                    'Integrate learnings'
                ],
                'recommended_timeouts': {
                    'first_pass': self.first_pass_timeout,
                    'second_pass': self.second_pass_timeout
                },
                'parallelization': self.router_intensity > 0.7,
                'rollback_likelihood': 0.3,
                'source': 'fallback_no_ai_service',
                'intensity': self.router_intensity,
                'warning': 'No AI service available, using defaults'
            }

        # Make AI call via mixin for complexity analysis (DRY!)
        complexity_level, estimated_duration, analysis = self.query_for_complexity(
            requirements=task_requirements,
            context=f"Two-pass pipeline optimization. "
                   f"Initial intensity: {self.router_intensity:.0%}. "
                   f"Router guidance: {self.router_guidance[:200]}..."
        )

        # Determine strategy based on AI complexity analysis
        complexity_to_strategy = {
            'simple': {
                'first_focus': ['Quick validation', 'Schema check', 'Dependency scan'],
                'second_focus': ['Direct implementation', 'Simple testing'],
                'timeouts': (int(self.first_pass_timeout * 0.8), int(self.second_pass_timeout * 0.8)),
                'parallel': False,
                'rollback': 0.05
            },
            'moderate': {
                'first_focus': ['Thorough analysis', 'Risk assessment', 'Architecture planning'],
                'second_focus': ['Structured implementation', 'Integration', 'Comprehensive testing'],
                'timeouts': (self.first_pass_timeout, self.second_pass_timeout),
                'parallel': False,
                'rollback': 0.15
            },
            'complex': {
                'first_focus': ['Deep analysis', 'Multiple risk scenarios', 'Detailed architecture', 'Prototyping'],
                'second_focus': ['Incremental implementation', 'Continuous validation', 'Extensive testing', 'Performance optimization'],
                'timeouts': (int(self.first_pass_timeout * 1.2), int(self.second_pass_timeout * 1.3)),
                'parallel': True,
                'rollback': 0.30
            },
            'very_complex': {
                'first_focus': ['Comprehensive analysis', 'Multiple prototypes', 'Risk mitigation plans', 'Architecture validation'],
                'second_focus': ['Phased implementation', 'Continuous feedback', 'Iterative refinement', 'Full test coverage'],
                'timeouts': (int(self.first_pass_timeout * 1.5), int(self.second_pass_timeout * 1.5)),
                'parallel': True,
                'rollback': 0.45
            }
        }

        strategy_config = complexity_to_strategy.get(complexity_level, complexity_to_strategy['moderate'])

        # Merge with router's guidance if available
        first_focus = strategy_config['first_focus']
        if self.first_pass_guidance:
            first_focus = list(set(first_focus + self.first_pass_guidance))

        second_focus = strategy_config['second_focus']
        if self.second_pass_guidance:
            second_focus = list(set(second_focus + self.second_pass_guidance))

        return {
            'first_pass_focus': first_focus,
            'second_pass_focus': second_focus,
            'recommended_timeouts': {
                'first_pass': strategy_config['timeouts'][0],
                'second_pass': strategy_config['timeouts'][1]
            },
            'parallelization': strategy_config['parallel'],
            'rollback_likelihood': strategy_config['rollback'],
            'source': 'ai_optimized',
            'complexity_level': complexity_level,
            'estimated_duration': estimated_duration,
            'ai_analysis': analysis,
            'initial_intensity': self.router_intensity,
            'initial_timeouts': {
                'first_pass': self.first_pass_timeout,
                'second_pass': self.second_pass_timeout
            },
            'timeout_adjustment': {
                'first_pass': strategy_config['timeouts'][0] - self.first_pass_timeout,
                'second_pass': strategy_config['timeouts'][1] - self.second_pass_timeout
            }
        }


# ============================================================================
# CONVENIENCE FACTORY
# ============================================================================


__all__ = ['TwoPassPipeline']
