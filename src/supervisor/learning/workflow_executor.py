from artemis_logger import get_logger
logger = get_logger('workflow_executor')
'\nWHY: Execute recovery workflows generated by learning system\nRESPONSIBILITY: Execute workflow steps, dispatch actions, track success\nPATTERNS: Command (workflow steps), Dispatch Table (action routing), Strategy (action executors)\n'
from typing import Dict, List, Optional, Any, Callable
from .models import LearnedSolution

class WorkflowStepExecutor:
    """
    WHY: Execute individual workflow steps safely
    RESPONSIBILITY: Dispatch to appropriate action handlers
    PATTERNS: Dispatch Table (action routing), Strategy (action executors)
    """

    def __init__(self, verbose: bool=True):
        self.verbose = verbose
        self._action_handlers = self._build_action_handlers()

    def _build_action_handlers(self) -> Dict[str, Callable]:
        """
        WHY: Avoid elif chains for action routing
        RESPONSIBILITY: Map action types to handler functions
        PATTERNS: Dispatch Table
        """
        return {'manual_intervention': self._execute_manual_intervention, 'retry_stage': self._execute_retry_stage, 'rollback_to_state': self._execute_rollback_to_state, 'cleanup_resources': self._execute_cleanup_resources, 'skip_stage': self._execute_skip_stage, 'reset_state': self._execute_reset_state, 'restart_process': self._execute_restart_process}

    def execute_step(self, step: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """
        WHY: Execute single workflow step with proper error handling
        RESPONSIBILITY: Route to action handler and return success status
        PATTERNS: Dispatch Table, Guard Clause

        Args:
            step: Workflow step to execute
            context: Execution context

        Returns:
            True if step succeeded, False otherwise
        """
        action = step.get('action', 'unknown')
        handler = self._action_handlers.get(action, self._execute_unknown_action)
        try:
            return handler(step, context)
        except Exception as e:
            if self.verbose:
                
                logger.log(f'[Learning]       ❌ Step execution failed: {e}', 'INFO')
            return False

    def _execute_manual_intervention(self, step: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """
        WHY: Handle steps requiring human intervention
        RESPONSIBILITY: Log manual intervention request
        """
        if self.verbose:
            
            logger.log(f"[Learning]       Action: {step.get('action')} - {step.get('description')}", 'INFO')
        return True

    def _execute_retry_stage(self, step: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """
        WHY: Retry failed stages
        RESPONSIBILITY: Trigger stage retry mechanism
        """
        if self.verbose:
            
            logger.log(f'[Learning]       Action: Retry stage', 'INFO')
        return True

    def _execute_rollback_to_state(self, step: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """
        WHY: Rollback to known-good state
        RESPONSIBILITY: Trigger state rollback
        """
        if not self.verbose:
            return True
        state = step.get('parameters', {}).get('target_state', 'unknown')
        
        logger.log(f'[Learning]       Action: Rollback to {state}', 'INFO')
        return True

    def _execute_cleanup_resources(self, step: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """
        WHY: Clean up stuck or leaked resources
        RESPONSIBILITY: Trigger resource cleanup
        """
        if self.verbose:
            
            logger.log(f'[Learning]       Action: Cleanup resources', 'INFO')
        return True

    def _execute_skip_stage(self, step: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """
        WHY: Skip problematic stages
        RESPONSIBILITY: Trigger stage skip
        """
        if self.verbose:
            
            logger.log(f'[Learning]       Action: Skip stage', 'INFO')
        return True

    def _execute_reset_state(self, step: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """
        WHY: Reset to clean initial state
        RESPONSIBILITY: Trigger state reset
        """
        if self.verbose:
            
            logger.log(f'[Learning]       Action: Reset state', 'INFO')
        return True

    def _execute_restart_process(self, step: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """
        WHY: Restart stuck processes
        RESPONSIBILITY: Trigger process restart
        """
        if self.verbose:
            
            logger.log(f'[Learning]       Action: Restart process', 'INFO')
        return True

    def _execute_unknown_action(self, step: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """
        WHY: Handle unknown action types gracefully
        RESPONSIBILITY: Log unknown action and simulate execution
        """
        action = step.get('action', 'unknown')
        if self.verbose:
            
            logger.log(f'[Learning]       Action: {action} (simulated)', 'INFO')
        return True

class WorkflowExecutionEngine:
    """
    WHY: Orchestrate execution of learned solution workflows
    RESPONSIBILITY: Execute workflow steps in sequence, track success
    PATTERNS: Template Method (execution flow), Strategy (step execution)
    """

    def __init__(self, verbose: bool=True):
        self.verbose = verbose
        self.step_executor = WorkflowStepExecutor(verbose=verbose)
        self.execution_count = 0
        self.success_count = 0

    def apply_solution(self, solution: LearnedSolution, context: Dict[str, Any]) -> bool:
        """
        WHY: Execute learned solution and track results
        RESPONSIBILITY: Run workflow steps, update success metrics
        PATTERNS: Template Method, Guard Clause

        Args:
            solution: The learned solution to apply
            context: Execution context

        Returns:
            True if all steps succeeded, False otherwise
        """
        self.execution_count += 1
        if self.verbose:
            
            logger.log(f'[Learning] 🔧 Applying learned solution: {solution.solution_id}', 'INFO')
            
            logger.log(f'[Learning]    Description: {solution.solution_description}', 'INFO')
        for i, step in enumerate(solution.workflow_steps, 1):
            if self.verbose:
                
                logger.log(f"[Learning]    Step {i}/{len(solution.workflow_steps)}: {step.get('action', 'unknown')}", 'INFO')
            success = self.step_executor.execute_step(step, context)
            if not success:
                if self.verbose:
                    
                    logger.log(f'[Learning]    ❌ Step {i} failed', 'INFO')
                solution.update_success_metrics(succeeded=False)
                return False
        solution.update_success_metrics(succeeded=True)
        self.success_count += 1
        if self.verbose:
            
            logger.log(f'[Learning] ✅ Solution applied successfully!', 'INFO')
            
            logger.log(f'[Learning]    Success rate: {solution.success_rate * 100:.1f}% ({solution.times_successful}/{solution.times_applied})', 'INFO')
        return True

    def get_stats(self) -> Dict[str, Any]:
        """Get execution statistics"""
        return {'executions': self.execution_count, 'successes': self.success_count, 'failures': self.execution_count - self.success_count, 'success_rate': self.success_count / self.execution_count if self.execution_count > 0 else 0.0}