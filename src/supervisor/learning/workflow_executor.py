#!/usr/bin/env python3
"""
WHY: Execute recovery workflows generated by learning system
RESPONSIBILITY: Execute workflow steps, dispatch actions, track success
PATTERNS: Command (workflow steps), Dispatch Table (action routing), Strategy (action executors)
"""

from typing import Dict, List, Optional, Any, Callable

from .models import LearnedSolution


class WorkflowStepExecutor:
    """
    WHY: Execute individual workflow steps safely
    RESPONSIBILITY: Dispatch to appropriate action handlers
    PATTERNS: Dispatch Table (action routing), Strategy (action executors)
    """

    def __init__(self, verbose: bool = True):
        self.verbose = verbose
        self._action_handlers = self._build_action_handlers()

    def _build_action_handlers(self) -> Dict[str, Callable]:
        """
        WHY: Avoid elif chains for action routing
        RESPONSIBILITY: Map action types to handler functions
        PATTERNS: Dispatch Table
        """
        return {
            "manual_intervention": self._execute_manual_intervention,
            "retry_stage": self._execute_retry_stage,
            "rollback_to_state": self._execute_rollback_to_state,
            "cleanup_resources": self._execute_cleanup_resources,
            "skip_stage": self._execute_skip_stage,
            "reset_state": self._execute_reset_state,
            "restart_process": self._execute_restart_process,
        }

    def execute_step(
        self,
        step: Dict[str, Any],
        context: Dict[str, Any]
    ) -> bool:
        """
        WHY: Execute single workflow step with proper error handling
        RESPONSIBILITY: Route to action handler and return success status
        PATTERNS: Dispatch Table, Guard Clause

        Args:
            step: Workflow step to execute
            context: Execution context

        Returns:
            True if step succeeded, False otherwise
        """
        action = step.get("action", "unknown")

        # Get handler from dispatch table
        handler = self._action_handlers.get(action, self._execute_unknown_action)

        # Execute with error handling
        try:
            return handler(step, context)
        except Exception as e:
            if self.verbose:
                print(f"[Learning]       ❌ Step execution failed: {e}")
            return False

    def _execute_manual_intervention(
        self,
        step: Dict[str, Any],
        context: Dict[str, Any]
    ) -> bool:
        """
        WHY: Handle steps requiring human intervention
        RESPONSIBILITY: Log manual intervention request
        """
        if self.verbose:
            print(f"[Learning]       Action: {step.get('action')} - {step.get('description')}")
        # Would trigger human notification in production
        return True

    def _execute_retry_stage(
        self,
        step: Dict[str, Any],
        context: Dict[str, Any]
    ) -> bool:
        """
        WHY: Retry failed stages
        RESPONSIBILITY: Trigger stage retry mechanism
        """
        if self.verbose:
            print(f"[Learning]       Action: Retry stage")
        # Would trigger stage retry in production
        return True

    def _execute_rollback_to_state(
        self,
        step: Dict[str, Any],
        context: Dict[str, Any]
    ) -> bool:
        """
        WHY: Rollback to known-good state
        RESPONSIBILITY: Trigger state rollback
        """
        if not self.verbose:
            return True
        state = step.get("parameters", {}).get("target_state", "unknown")
        print(f"[Learning]       Action: Rollback to {state}")
        # Would trigger rollback in production
        return True

    def _execute_cleanup_resources(
        self,
        step: Dict[str, Any],
        context: Dict[str, Any]
    ) -> bool:
        """
        WHY: Clean up stuck or leaked resources
        RESPONSIBILITY: Trigger resource cleanup
        """
        if self.verbose:
            print(f"[Learning]       Action: Cleanup resources")
        # Would trigger resource cleanup in production
        return True

    def _execute_skip_stage(
        self,
        step: Dict[str, Any],
        context: Dict[str, Any]
    ) -> bool:
        """
        WHY: Skip problematic stages
        RESPONSIBILITY: Trigger stage skip
        """
        if self.verbose:
            print(f"[Learning]       Action: Skip stage")
        # Would trigger stage skip in production
        return True

    def _execute_reset_state(
        self,
        step: Dict[str, Any],
        context: Dict[str, Any]
    ) -> bool:
        """
        WHY: Reset to clean initial state
        RESPONSIBILITY: Trigger state reset
        """
        if self.verbose:
            print(f"[Learning]       Action: Reset state")
        # Would trigger state reset in production
        return True

    def _execute_restart_process(
        self,
        step: Dict[str, Any],
        context: Dict[str, Any]
    ) -> bool:
        """
        WHY: Restart stuck processes
        RESPONSIBILITY: Trigger process restart
        """
        if self.verbose:
            print(f"[Learning]       Action: Restart process")
        # Would trigger process restart in production
        return True

    def _execute_unknown_action(
        self,
        step: Dict[str, Any],
        context: Dict[str, Any]
    ) -> bool:
        """
        WHY: Handle unknown action types gracefully
        RESPONSIBILITY: Log unknown action and simulate execution
        """
        action = step.get("action", "unknown")
        if self.verbose:
            print(f"[Learning]       Action: {action} (simulated)")
        return True


class WorkflowExecutionEngine:
    """
    WHY: Orchestrate execution of learned solution workflows
    RESPONSIBILITY: Execute workflow steps in sequence, track success
    PATTERNS: Template Method (execution flow), Strategy (step execution)
    """

    def __init__(self, verbose: bool = True):
        self.verbose = verbose
        self.step_executor = WorkflowStepExecutor(verbose=verbose)
        self.execution_count = 0
        self.success_count = 0

    def apply_solution(
        self,
        solution: LearnedSolution,
        context: Dict[str, Any]
    ) -> bool:
        """
        WHY: Execute learned solution and track results
        RESPONSIBILITY: Run workflow steps, update success metrics
        PATTERNS: Template Method, Guard Clause

        Args:
            solution: The learned solution to apply
            context: Execution context

        Returns:
            True if all steps succeeded, False otherwise
        """
        self.execution_count += 1

        if self.verbose:
            print(f"[Learning] 🔧 Applying learned solution: {solution.solution_id}")
            print(f"[Learning]    Description: {solution.solution_description}")

        # Execute workflow steps
        for i, step in enumerate(solution.workflow_steps, 1):
            if self.verbose:
                print(f"[Learning]    Step {i}/{len(solution.workflow_steps)}: {step.get('action', 'unknown')}")

            success = self.step_executor.execute_step(step, context)

            # Guard: Step failed
            if not success:
                if self.verbose:
                    print(f"[Learning]    ❌ Step {i} failed")
                solution.update_success_metrics(succeeded=False)
                return False

        # All steps succeeded
        solution.update_success_metrics(succeeded=True)
        self.success_count += 1

        if self.verbose:
            print(f"[Learning] ✅ Solution applied successfully!")
            print(f"[Learning]    Success rate: {solution.success_rate*100:.1f}% ({solution.times_successful}/{solution.times_applied})")

        return True

    def get_stats(self) -> Dict[str, Any]:
        """Get execution statistics"""
        return {
            "executions": self.execution_count,
            "successes": self.success_count,
            "failures": self.execution_count - self.success_count,
            "success_rate": self.success_count / self.execution_count if self.execution_count > 0 else 0.0
        }
